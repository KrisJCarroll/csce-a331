-- PA5.hs
-- Author: Kristopher Carroll
-- Updated: April 7, 2019
-- CSCE A331 - Programming Language Concepts
-- Assignment 5 Exercise B

module PA5 where
-- collatz
-- Takes an Integer and returns the resulting Integer using the Collatz function
collatz :: Int -> Int
collatz n 
    | n `mod` 2 == 1    = (3 * n) + 1
    | otherwise         = n `div` 2 

-- collatzSeq
-- Takes an Integer and returns the Collatz sequence starting from that number
collatzSeq :: Int -> [Int]
collatzSeq x
    | x <= 0    = error "The number must be an integer greater than 0."
    | x == 1    = [x]
    | otherwise = x:collatzSeq (collatz x)

-- collatzCount
-- Helper function to map values in collatzCounts
-- Finds the length of the Collatz sequence for an index + 1
collatzCount :: Int -> Int
collatzCount n
    | n == 0            = 0
    | otherwise         = length (collatzSeq (n + 1)) - 1

-- collatzCounts
-- Infinite list where the value of index n is the number of steps of the Collatz function it takes to 
-- take n + 1 to equal 1
collatzCounts :: [Int]
-- collatzCounts = map collatzCount [0..] -- alternative method of creating collatzCounts by mapping collatzCount to the range
collatzCounts = [collatzCount x | x <- [0..] ]

-- tails
-- Takes a list and returns all the sublists generated by successively removing the item
-- at the head of the original list
-- Adapted from blank found at: 
-- https://www.reddit.com/r/haskell/comments/614yqm/newbie_problem/dfciahx?utm_source=share&utm_medium=web2x
tails :: [a] -> [[a]]
tails [] = [] -- Empty list 
tails (x:xs) = (x:xs):tails xs -- add (x:xs) to the list and recurse on xs

-- isSublist
-- Takes two lists of equality comparable values and determines if 
-- the first list is contained within the second list
-- Adapted from blank found at:
-- https://www.reddit.com/r/haskell/comments/614yqm/newbie_problem/dfciahx?utm_source=share&utm_medium=web2x
isSublist :: (Eq a) => [a] -> [a] -> Bool
isSublist [] _ = True -- empty list is a sublist of all lists, base case
isSublist _ [] = False -- no more values to check in second list, false
isSublist (x:xs) (y:ys)
    | x == y        = isSublist xs ys -- recurse on remaining portions of lists
    | otherwise     = False -- shouldn't be reached

-- findIndex
-- Takes a predicate and a list and returns a Maybe Int of the index in the list where
-- the predicate returns True
-- Adapted from blank found at: 
-- https://www.reddit.com/r/haskell/comments/614yqm/newbie_problem/dfciahx?utm_source=share&utm_medium=web2x
findIndex :: (a -> Bool) -> [a] -> Maybe Int
findIndex pred = go 0 where -- start at index 0
    go _ [] = Nothing -- predicate was never fulfilled, not found in list
    go n (x:xs)
        | pred x       = Just n -- predicate fulfilled, Just n is the index where it became true
        | otherwise    = go (n+1) xs -- increase index and recurse on remaining list
    

-- findList
-- Takes two lists and returns the earliest index at which the first list is found to be a continuous sublist
-- of the second list
-- Notes:
--      tails ys - creates a list of all sublists of the second input list by successively removing the first element
--      findIndex (isSublist xs) - finds the first index where xs is a sublist of the above list of sublists
findList :: Eq a => [a] -> [a] -> Maybe Int
findList xs ys = findIndex (isSublist xs) (tails ys)

-- findIndices
-- Takes a predicate and a list and returns a list of Ints representing the indices at which the 
-- predicate was fulfilled in the list
-- Note: not used in this assignment, implemented as an exercise after the above
findIndices :: (a -> Bool) -> [a] -> [Int]
findIndices pred = go 0 where
    go _ [] = []
    go n (x:xs)
        | pred x        = n:go (n+1) xs
        | otherwise     = go (n+1) xs

-- operator ##
-- takes two lists of equality comparable values and returns the number of matching values found
(##) :: Eq a => [a] -> [a] -> Int
[] ## _ = 0
_ ## [] = 0
(l:ls) ## (r:rs)
    | l == r    = 1 + (ls ## rs)
    | otherwise = ls ## rs


-- filterAB
-- takes a predicate and two lists and returns the corresponding elements in the second list for which
-- the element in the first list fulfills the predicate
filterAB :: (a -> Bool) -> [a] -> [b] -> [b]
filterAB pred [] _ = []
filterAB pred _ [] = []
filterAB pred (x:xs) (y:ys)
    | pred x        = y:filterAB pred xs ys
    | otherwise     = filterAB pred xs ys



-- sumEvenOdd
-- Not implemented
sumEvenOdd :: Num a => [a] -> (a, a)
sumEvenOdd [] = (0, 0)
sumEvenOdd xs = (1, 1)


